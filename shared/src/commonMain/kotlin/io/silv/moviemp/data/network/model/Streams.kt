package io.silv.moviemp.data.network.model

import io.silv.moviemp.core.StreamItem
import kotlinx.datetime.Instant
import kotlinx.datetime.TimeZone
import kotlinx.datetime.atStartOfDayIn
import kotlinx.datetime.toInstant
import kotlinx.datetime.toLocalDate
import kotlinx.datetime.toLocalDateTime
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

object SafeInstantSerializer : KSerializer<Instant> {
    override val descriptor = PrimitiveSerialDescriptor("Instant", PrimitiveKind.STRING)

    override fun deserialize(decoder: Decoder): Instant {
        val string = decoder.decodeString()
        return try {
            string.toInstant()
        } catch (e: IllegalArgumentException) {
            string.toLocalDate().atStartOfDayIn(TimeZone.currentSystemDefault())
        }
    }

    override fun serialize(encoder: Encoder, value: Instant) {
        encoder.encodeString(value.toString())
    }
}

enum class FileType {
    AUDIO,
    VIDEO,
    SUBTITLE
}

@Serializable
data class Subtitle(
    val url: String? = null,
    val mimeType: String? = null,
    val name: String? = null,
    val code: String? = null,
    val autoGenerated: Boolean? = null
)


@Serializable
data class MetaInfo(
    val title: String,
    val description: String,
    val urls: List<String>,
    val urlTexts: List<String>
)

@Serializable
data class PipedStream(
    val url: String? = null,
    val format: String? = null,
    val quality: String? = null,
    val mimeType: String? = null,
    val codec: String? = null,
    val videoOnly: Boolean? = null,
    val bitrate: Int? = null,
    val initStart: Int? = null,
    val initEnd: Int? = null,
    val indexStart: Int? = null,
    val indexEnd: Int? = null,
    val width: Int? = null,
    val height: Int? = null,
    val fps: Int? = null,
    val audioTrackName: String? = null,
    val audioTrackId: String? = null,
    val contentLength: Long = -1,
    val audioTrackType: String? = null,
    val audioTrackLocale: String? = null
) {
    private fun getQualityString(fileName: String): String {
        return "${fileName}_${quality?.replace(" ", "_")}_$format." +
                mimeType?.split("/")?.last()
    }
}

@Serializable
data class ChapterSegment(
    val title: String,
    val image: String = "",
    val start: Long,
    // Used only for video highlights
) {
    companion object {
        /**
         * Length to show for a highlight in seconds
         */
        const val HIGHLIGHT_LENGTH = 10L
    }
}

@Serializable
data class PreviewFrames(
    val urls: List<String>,
    val frameWidth: Int,
    val frameHeight: Int,
    val totalCount: Int,
    val durationPerFrame: Long,
    val framesPerPageX: Int,
    val framesPerPageY: Int
)

@Serializable
data class Streams(
    val title: String,
    val description: String,

    @Serializable(SafeInstantSerializer::class)
    @SerialName("uploadDate")
    val uploadTimestamp: Instant,

    val uploader: String,
    val uploaderUrl: String,
    val uploaderAvatar: String? = null,
    val thumbnailUrl: String,
    val category: String,
    val license: String = "YouTube licence",
    val visibility: String = "public",
    val tags: List<String> = emptyList(),
    val metaInfo: List<MetaInfo> = emptyList(),
    val hls: String? = null,
    val dash: String? = null,
    val lbryId: String? = null,
    val uploaderVerified: Boolean,
    val duration: Long,
    val views: Long = 0,
    val likes: Long = 0,
    val dislikes: Long = 0,
    val audioStreams: List<PipedStream> = emptyList(),
    val videoStreams: List<PipedStream> = emptyList(),
    var relatedStreams: List<StreamItem> = emptyList(),
    val subtitles: List<Subtitle> = emptyList(),
    val livestream: Boolean = false,
    val proxyUrl: String? = null,
    val chapters: List<ChapterSegment> = emptyList(),
    val uploaderSubscriberCount: Long = 0,
    val previewFrames: List<PreviewFrames> = emptyList()
) {

    companion object {
        const val categoryMusic = "Music"
    }
}

fun Streams.toStreamItem(videoId: String): StreamItem {
    return StreamItem(
        url = videoId,
        title = title,
        thumbnail = thumbnailUrl,
        uploaderName = uploader,
        uploaderUrl = uploaderUrl,
        uploaderAvatar = uploaderAvatar,
        uploadedDate = uploadTimestamp.toLocalDateTime(TimeZone.currentSystemDefault()).date
            .toString(),
        uploaded = uploadTimestamp.epochSeconds,
        duration = duration,
        views = views,
        uploaderVerified = uploaderVerified,
        shortDescription = description
    )
}
